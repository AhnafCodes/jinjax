{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"El poder de los componentes en tu aplicaci\u00f3n web Python basada en plantillas. Mejor que include y macros . Simples: m\u00e1s f\u00e1ciles de leer y usar porque se ven como HTML normal. Practicos: archivos Jinja regulares sin tener que importarlos. Componibles: pueden envolver contenido (HTML, otros componentes, etc.) de forma natural. Encapsulados: pueden apuntar a sus propios archivos css o js y copiarse/pegarse a otros proyectos sin modificaciones. \u00bfJusto lo que buscabas? Mira la documentaci\u00f3n Dile adi\u00f3s a las plantillas espaguetis. Queremos que nuestro c\u00f3digo Python sea f\u00e1cil de entender y de probar. El c\u00f3digo de las plantillas, sin embargo, a menudo falla incluso est\u00e1ndares de c\u00f3digo b\u00e1sicos : m\u00e9todos largu\u00edsimos, condicionales de muchos niveles de profundidad, y variables misteriosas por todos lados. Pero cuando usas componentes, puedes ver donde est\u00e1 todo, entender cuales son los posibles estados de cada pieza de UI, y saber ex\u00e1ctamente que datos necesitan tener. Puedes reemplazar todas tus plantillas con componentes . \u00bfUsando {% extend %} con una plantilla base? \u00a1Crea un componente Pagina en cambio! R\u00e1pido de escribir, asombroso de usar. As\u00ed es como se v\u00e9 un componente: \u00bfComenzamos? Adelante: Mira la documentaci\u00f3n \u00a1Millones de personas hicieron click en un bot\u00f3n solo en la \u00faltima semana!","title":"Inicio"},{"location":"guide/","text":"Empieza aqu\u00ed # Instalaci\u00f3n # Instala el paquete usando pip . pip install tcom Como usar # La primera cosa que tienes que hacer, es crear un \u201ccat\u00e1logo\u201d de componentes. Este es el objeto que maneja los componentes y su configuraci\u00f3n global. Luego de eso, a\u00f1ades al cat\u00e1logo los folders con tus componentes. from tcom import Catalog catalog = Catalog () catalog . add_folder ( \"myapp/components\" ) Usas el cat\u00e1logo para renderizar los componente de tus vistas: def posts (): ... return catalog . render ( \"PostsIndex\" , title = \"Lorem ipsum\" , posts = posts_list , ) Componentes # Los components son archivos .jinja . El nombre del archivo antes del primer punto es el nombre del componente y debe empezar con may\u00fascula. Esta es la \u00fanica forma de distinguirlos de etiquetas HTML normales. Por ejemplo, si el archivo se llama PersonForm.jinja , el nombre del componente es PersonForm y puede ser usado como <PersonForm>...</PersonForm> . Un componente puede empezar con un comentario Jinja donde declaras que argumentos puede recibir. Algunos de estos argumentos pueden tener un valor por defecto (haci\u00e9ndolos opcionales): {#def title, message='Hi' #} < h1 > {{ title }} </ h1 > < div > {{ message }} . Este archivo es un componente </ div > Jinja # Template Components usa Jinja internamente para renderizar las plantillas. Puedes agregar tus propias variables globales, filtros, tests y extensiones de Jinja, al crear el cat\u00e1logo: from tcom import Catalog catalog = Catalog ( globals = { ... }, filters = { ... }, tests = { ... }, extensions = [], ) o despu\u00e9s, actualizando el jinja.Environment ya creado: catalog . jinja_env . globals . update ({ ... }) catalog . jinja_env . filters . update ({ ... }) catalog . jinja_env . tests . update ({ ... }) catalog . jinja_env . extensions . extend ([ ... ]) Si usas Flask , por ejemplo, deber\u00edas pasarle los valores de su propio entorno Jinja: app = Flask ( __name__ ) catalog = tcom . Catalog ( globals = app . globals , filters = app . filters , tests = app . tests , extensions = app . extensions , ) La extensi\u00f3n \u201cdo\u201d est\u00e1 activada por defecto, para que puedas escribir cosas como: {% do attrs.add_class ( \"btn\" ) %}","title":"Empieza aqu\u00ed"},{"location":"guide/#empieza-aqui","text":"","title":"Empieza aqu\u00ed"},{"location":"guide/#instalacion","text":"Instala el paquete usando pip . pip install tcom","title":"Instalaci\u00f3n"},{"location":"guide/#como-usar","text":"La primera cosa que tienes que hacer, es crear un \u201ccat\u00e1logo\u201d de componentes. Este es el objeto que maneja los componentes y su configuraci\u00f3n global. Luego de eso, a\u00f1ades al cat\u00e1logo los folders con tus componentes. from tcom import Catalog catalog = Catalog () catalog . add_folder ( \"myapp/components\" ) Usas el cat\u00e1logo para renderizar los componente de tus vistas: def posts (): ... return catalog . render ( \"PostsIndex\" , title = \"Lorem ipsum\" , posts = posts_list , )","title":"Como usar"},{"location":"guide/#componentes","text":"Los components son archivos .jinja . El nombre del archivo antes del primer punto es el nombre del componente y debe empezar con may\u00fascula. Esta es la \u00fanica forma de distinguirlos de etiquetas HTML normales. Por ejemplo, si el archivo se llama PersonForm.jinja , el nombre del componente es PersonForm y puede ser usado como <PersonForm>...</PersonForm> . Un componente puede empezar con un comentario Jinja donde declaras que argumentos puede recibir. Algunos de estos argumentos pueden tener un valor por defecto (haci\u00e9ndolos opcionales): {#def title, message='Hi' #} < h1 > {{ title }} </ h1 > < div > {{ message }} . Este archivo es un componente </ div >","title":"Componentes"},{"location":"guide/#jinja","text":"Template Components usa Jinja internamente para renderizar las plantillas. Puedes agregar tus propias variables globales, filtros, tests y extensiones de Jinja, al crear el cat\u00e1logo: from tcom import Catalog catalog = Catalog ( globals = { ... }, filters = { ... }, tests = { ... }, extensions = [], ) o despu\u00e9s, actualizando el jinja.Environment ya creado: catalog . jinja_env . globals . update ({ ... }) catalog . jinja_env . filters . update ({ ... }) catalog . jinja_env . tests . update ({ ... }) catalog . jinja_env . extensions . extend ([ ... ]) Si usas Flask , por ejemplo, deber\u00edas pasarle los valores de su propio entorno Jinja: app = Flask ( __name__ ) catalog = tcom . Catalog ( globals = app . globals , filters = app . filters , tests = app . tests , extensions = app . extensions , ) La extensi\u00f3n \u201cdo\u201d est\u00e1 activada por defecto, para que puedas escribir cosas como: {% do attrs.add_class ( \"btn\" ) %}","title":"Jinja"},{"location":"guide/arguments/","text":"Atributos de componentes # A menudo, un componente toma uno o m\u00e1s argumentos para renderizar, podr\u00eda ser una fecha, una lista de art\u00edculos o un texto. Cada argumento debe ser declarado en la metadata (el comentario al principio) del componente con {#def arguments #} . La sintaxis es muy similar a la declaraci\u00f3n de una funci\u00f3n en python: components/Form.jinja {#def action, method='post', multipart=False #} < form method = \" {{ method }} \" action = \" {{ action }} \" {% - if multipart %} enctype = \"multipart/form-data\" {% endif %} > {{ content }} </ form > En este ejemplo, el componente toma tres argumentos: \u201caction\u201d, \u201cmethod\u201d, y \u201cmultipart\u201d. Los \u00faltimos dos tienen un valor por defecto, de modo que son opcionales - no necesitas pasarlos para llamar al componente. El primer argumento no tiene un valor, asi que tienes que pasarle un valor cuando llames al componente. As\u00ed que todas estas son formas v\u00e1lidas de usar este componente: < Form action = \"/new\" > ... </ Form > < Form action = \"/new\" method = \"PATCH\" > ... </ Form > < Form multipart = {False} action = \"/new\" > ... </ Form > Los valores de los argumentos declarados pueden usarse en la plantilla como variables con el mismo nombre. Atributos que no son textos # En el ejemplo anterior, tanto \u201caction\u201d como \u201cmethod\u201d son cadenas de texto, pero \u201cmultipart\u201d es un booleano. No podemos pasarlo como multipart=\"false\" porque eso lo volveria un texto, que adem\u00e1s evaluar\u00eda a verdadero, que es lo opuesto a lo que queremos. En vez de eso, debemos usar llaves en vez de comillas( nombre={ valor } en vez de nombre=\"valor\" ). Dentro de las llaves, puedes usar fechas, objetos, listas, o cualquier expresi\u00f3n de Python. {# Un valor de fecha #} < DateTime date = {datetime_value} /> {# Un objeto #} < Post post = {post} /> {# C\u00e1lculos al vuelo #} < FooBar number = {2**10} /> {# Una lista #} < FooBar items = {[1,2,3,4]} /> Componentes con contenido # Hasta ahora, hemos visto componentes que terminan en /> , sin una etiqueta de cierre. Pero hay otro tipo, mucho m\u00e1s \u00fatil: componentes que envuelven otras etiquetas HTML y/o a otros componentes. {# Componente de cierre autom\u00e1tico #} < Name arguments /> {# Componente con contenido #} < Name arguments > ...content here... </ Name > Un gran caso de uso es hacer componentes de base: components/PageLayout.jinja {#def title #} <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > {{ title }} </ title > </ head > < body > {{ content }} </ body > components/ArchivePage.jinja {#def posts #} < PageLayout title = \"Archive\" > {% for post in posts %} < Post post = {{ post }} / > {% endfor %} </ PageLayout > Todo entre las etiquetas inicial y de cierre del componente ser\u00e1 renderizado y pasado al componente PageLayout en una variable impl\u00edcita especial content . Para probar un componente en aislamiento, puedes tambi\u00e9n definir manualmente el contenido con el argumento especial __content : catalog . render ( \"PageLayout\" , title = \"Hello world\" , __content = \"TEST\" ) Atributos extra # Si le pasas argumentos no declarados a un componentes, estos no son descartados, si no, en cambio, recogidos en un objeto attrs . Lee m\u00e1s acerca de esto en la siguiente secci\u00f3n.","title":"Atributos de componentes"},{"location":"guide/arguments/#atributos-de-componentes","text":"A menudo, un componente toma uno o m\u00e1s argumentos para renderizar, podr\u00eda ser una fecha, una lista de art\u00edculos o un texto. Cada argumento debe ser declarado en la metadata (el comentario al principio) del componente con {#def arguments #} . La sintaxis es muy similar a la declaraci\u00f3n de una funci\u00f3n en python: components/Form.jinja {#def action, method='post', multipart=False #} < form method = \" {{ method }} \" action = \" {{ action }} \" {% - if multipart %} enctype = \"multipart/form-data\" {% endif %} > {{ content }} </ form > En este ejemplo, el componente toma tres argumentos: \u201caction\u201d, \u201cmethod\u201d, y \u201cmultipart\u201d. Los \u00faltimos dos tienen un valor por defecto, de modo que son opcionales - no necesitas pasarlos para llamar al componente. El primer argumento no tiene un valor, asi que tienes que pasarle un valor cuando llames al componente. As\u00ed que todas estas son formas v\u00e1lidas de usar este componente: < Form action = \"/new\" > ... </ Form > < Form action = \"/new\" method = \"PATCH\" > ... </ Form > < Form multipart = {False} action = \"/new\" > ... </ Form > Los valores de los argumentos declarados pueden usarse en la plantilla como variables con el mismo nombre.","title":"Atributos de componentes"},{"location":"guide/arguments/#atributos-que-no-son-textos","text":"En el ejemplo anterior, tanto \u201caction\u201d como \u201cmethod\u201d son cadenas de texto, pero \u201cmultipart\u201d es un booleano. No podemos pasarlo como multipart=\"false\" porque eso lo volveria un texto, que adem\u00e1s evaluar\u00eda a verdadero, que es lo opuesto a lo que queremos. En vez de eso, debemos usar llaves en vez de comillas( nombre={ valor } en vez de nombre=\"valor\" ). Dentro de las llaves, puedes usar fechas, objetos, listas, o cualquier expresi\u00f3n de Python. {# Un valor de fecha #} < DateTime date = {datetime_value} /> {# Un objeto #} < Post post = {post} /> {# C\u00e1lculos al vuelo #} < FooBar number = {2**10} /> {# Una lista #} < FooBar items = {[1,2,3,4]} />","title":"Atributos que no son textos"},{"location":"guide/arguments/#componentes-con-contenido","text":"Hasta ahora, hemos visto componentes que terminan en /> , sin una etiqueta de cierre. Pero hay otro tipo, mucho m\u00e1s \u00fatil: componentes que envuelven otras etiquetas HTML y/o a otros componentes. {# Componente de cierre autom\u00e1tico #} < Name arguments /> {# Componente con contenido #} < Name arguments > ...content here... </ Name > Un gran caso de uso es hacer componentes de base: components/PageLayout.jinja {#def title #} <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > {{ title }} </ title > </ head > < body > {{ content }} </ body > components/ArchivePage.jinja {#def posts #} < PageLayout title = \"Archive\" > {% for post in posts %} < Post post = {{ post }} / > {% endfor %} </ PageLayout > Todo entre las etiquetas inicial y de cierre del componente ser\u00e1 renderizado y pasado al componente PageLayout en una variable impl\u00edcita especial content . Para probar un componente en aislamiento, puedes tambi\u00e9n definir manualmente el contenido con el argumento especial __content : catalog . render ( \"PageLayout\" , title = \"Hello world\" , __content = \"TEST\" )","title":"Componentes con contenido"},{"location":"guide/arguments/#atributos-extra","text":"Si le pasas argumentos no declarados a un componentes, estos no son descartados, si no, en cambio, recogidos en un objeto attrs . Lee m\u00e1s acerca de esto en la siguiente secci\u00f3n.","title":"Atributos extra"},{"location":"guide/css_and_js/","text":"Agregando CSS y JS # Tus componentes pueden necesitar estilos propios o JavaScript por muchas razones. En vez de usar estilos o scripts globales a todo el sitio, escribir CSS/JS para cada componente individual tiene muchas ventajas: Portabilidad : Puedes copiar un componente, de un proyecto a otro, sabiendo que seguir\u00e1 funcionando como debe. Rendimiento : En cada p\u00e1gina solo carga el CSS/JS que necesitas. Adem\u00e1s, el navegador habr\u00e1 guardado en cach\u00e9 los recursos de los componentes que ya hayas usado en otras p\u00e1ginas, as\u00ed que no tendr\u00e1 que cargarlos de nuevo. Pruebas m\u00e1s simple : Puedes probar el JavaScript de un componente independientemente de los otros. Declarando CSS/JS # El CSS y/o el JS de un componente deben ser declarados en la metadata de la cabecera usando {#css ... #} y {#js ... #} {#css lorem.css ipsum.css #} {#js foo.js bar.js #} Ambas listas son opcionales. Las rutas deben ser relativas a la ra\u00edz del folder de componentes (e.g.: components/ ). Incluyendo los CSS/JS en tu p\u00e1gina # El cat\u00e1logo recoger\u00e1 todas las rutas de los archivos CSS y JS de los componentes usados en una p\u00e1gina en las listas catalog.collected_css y catalog.collected_js . Por ejemplo, despues de renderizar este componente: components/MyPage.jinja {#css mypage.css #} {#js mypage.js #} < Layout title = \"My page\" > < Card > < CardBody > < h1 > Lizard </ h1 > < p > The Iguana is a type of lizard </ p > </ CardBody > < CardActions > < Button size = \"small\" > Share </ Button > </ CardActions > </ Card > </ Layout > Suponiendo que los componentes Card , y Button declaren recursos CSS, este ser\u00e1 el estado de la lista collected_css : catalog . collected_css [ 'mypage.css' , 'card.css' , 'button.css' ] Puedes agregar etiquetas <link> y <script> en tu p\u00e1gina autom\u00e1ticamente, imprimiendo la variable global impl\u00edcita components_assets en tu componente base, as\u00ed: components/Layout.jinja {#def title #} <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > {{ title }} </ title > {{ components_assets }} </ head > < body > {{ content }} </ body > </ html > Esa variable se renderizar\u00e1 como: < link rel = \"stylesheet\" href = \"/static/components/mypage.css\" > < link rel = \"stylesheet\" href = \"/static/components/card.css\" > < link rel = \"stylesheet\" href = \"/static/components/button.css\" > < script src = \"/static/components/mypage.js\" defer ></ script > < script src = \"/static/components/card.js\" defer ></ script > < script src = \"/static/components/button.js\" defer ></ script > Middleware # Las etiquetas <link> y <script> de arriba no servir\u00e1n de nada si tu aplicaci\u00f3n no puede servir esos archivos, y no puede hacerlo a\u00fan. Por esa raz\u00f3n, Template Components incluye un middleware WSGI que procesar\u00e1 URLs como esas y devolver\u00e1 los archivos correctos, si lo agregas a tu aplicaci\u00f3n. from flask import Flask from tcom import Catalog app = Flask ( __name__ ) # Aqu\u00ed agregamos las variables globales, filtros, etc. de # las plantillas de Flask, como por ejemplo `url_for()` catalog = tcom . Catalog ( globals = app . jinja_env . globals , filters = app . jinja_env . filters , tests = app . jinja_env . tests , extensions = app . jinja_env . extensions , ) catalog . add_folder ( \"myapp/components\" ) app . wsgi_app = catalog . get_middleware ( app . wsgi_app , autorefresh = app . debug , ) El middleware usa la \u201cprobada en batalla\u201d librer\u00eda Whitenoise y solo devolver\u00e1 archivos .css y/o .js dentro de el(los) folder(s) de los componentes (puedes configurarlo para que tambi\u00e9n devuelva archivos con otras extensiones). Buenas pr\u00e1cticas # Alcance del CSS # Los estilos no se auto-limitar\u00e1n a tu componente. Esto significa que podr\u00edan afectar a otros componentes y, a la inversa, ser afectados por estilos globales o de otros componentes. Para protegerte de esto, siempre usa una clase \u00fanica en la(s) etiqueta(s) ra\u00edz del componente y \u00fasala para limitar el resto de los estilos. Ejemplo: components/Card.jinja {#css card.css #} {% do attrs.add_class ( \"Card\" ) - %} < div {{ attrs.render () }} > < h1 > My Card </ h1 > ... </ div > components/card.css /* \ud83d\udeab NO HAGAS ESTO */ h1 { font-size : 2 em ; } h2 { font-size : 1.5 em ; } a { color : blue ; } /* \ud83d\udc4d HAZ ESTO en vez */ . Card h1 { font-size : 2 em ; } . Card h2 { font-size : 1.5 em ; } . Card a { color : blue ; } Siempre usa una clase en vez de un id , o el componente no podr\u00e1 ser usado m\u00e1s de una vez en una misma p\u00e1gina. Eventos de JavaScript # Tus componentes podr\u00edan ser insertados al vuelo en la p\u00e1gina, despu\u00e9s de que el JavaScript haya sido cargado y ejecutado. Por eso, conectar eventos a los elementos al cargar la p\u00e1gina no ser\u00e1 suficiente: components/card.js // Esto fallar\u00e1 para cualquier <Card> insertado despu\u00e9s document . querySelectorAll ( '.Card button.share' ) . forEach ( ( node ) => { node . addEventListener ( \"click\" , handleClick ) }) /* ... etc. ... */ Una alternativa puede ser usar el API JavaScript MutationObserver para detectar cambios en el documento y conectar eventos a los nuevos componentes insertados: components/card.js new MutationObserver ( ( mutationList ) => { mutationList . forEach ( ( mutation ) => { if ( mutation . type !== \"childList\" ) return mutation . addedNodes . forEach ( ( node ) => { if ( node . nodeType === 1 ) { addEvents ( node ) } }) }) }) . observe ( document . body , { subtree : true , childList : true , attributes : false , characterData : false }) function addEvents ( root ) { /* Agrega eventos a todos los elementos hijos de los nuevos elementos insertados */ root . querySelectorAll ( '.Card button.share' ) . forEach ( ( node ) => { node . addEventListener ( \"click\" , handleClick ) }) } // Una primera llamada para conectar los eventos a los componentes // presentes en la p\u00e1gina cuando carga addEvents ( document ) /* ... etc ... */","title":"Agregando CSS y JS"},{"location":"guide/css_and_js/#agregando-css-y-js","text":"Tus componentes pueden necesitar estilos propios o JavaScript por muchas razones. En vez de usar estilos o scripts globales a todo el sitio, escribir CSS/JS para cada componente individual tiene muchas ventajas: Portabilidad : Puedes copiar un componente, de un proyecto a otro, sabiendo que seguir\u00e1 funcionando como debe. Rendimiento : En cada p\u00e1gina solo carga el CSS/JS que necesitas. Adem\u00e1s, el navegador habr\u00e1 guardado en cach\u00e9 los recursos de los componentes que ya hayas usado en otras p\u00e1ginas, as\u00ed que no tendr\u00e1 que cargarlos de nuevo. Pruebas m\u00e1s simple : Puedes probar el JavaScript de un componente independientemente de los otros.","title":"Agregando CSS y JS"},{"location":"guide/css_and_js/#declarando-cssjs","text":"El CSS y/o el JS de un componente deben ser declarados en la metadata de la cabecera usando {#css ... #} y {#js ... #} {#css lorem.css ipsum.css #} {#js foo.js bar.js #} Ambas listas son opcionales. Las rutas deben ser relativas a la ra\u00edz del folder de componentes (e.g.: components/ ).","title":"Declarando CSS/JS"},{"location":"guide/css_and_js/#incluyendo-los-cssjs-en-tu-pagina","text":"El cat\u00e1logo recoger\u00e1 todas las rutas de los archivos CSS y JS de los componentes usados en una p\u00e1gina en las listas catalog.collected_css y catalog.collected_js . Por ejemplo, despues de renderizar este componente: components/MyPage.jinja {#css mypage.css #} {#js mypage.js #} < Layout title = \"My page\" > < Card > < CardBody > < h1 > Lizard </ h1 > < p > The Iguana is a type of lizard </ p > </ CardBody > < CardActions > < Button size = \"small\" > Share </ Button > </ CardActions > </ Card > </ Layout > Suponiendo que los componentes Card , y Button declaren recursos CSS, este ser\u00e1 el estado de la lista collected_css : catalog . collected_css [ 'mypage.css' , 'card.css' , 'button.css' ] Puedes agregar etiquetas <link> y <script> en tu p\u00e1gina autom\u00e1ticamente, imprimiendo la variable global impl\u00edcita components_assets en tu componente base, as\u00ed: components/Layout.jinja {#def title #} <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > {{ title }} </ title > {{ components_assets }} </ head > < body > {{ content }} </ body > </ html > Esa variable se renderizar\u00e1 como: < link rel = \"stylesheet\" href = \"/static/components/mypage.css\" > < link rel = \"stylesheet\" href = \"/static/components/card.css\" > < link rel = \"stylesheet\" href = \"/static/components/button.css\" > < script src = \"/static/components/mypage.js\" defer ></ script > < script src = \"/static/components/card.js\" defer ></ script > < script src = \"/static/components/button.js\" defer ></ script >","title":"Incluyendo los CSS/JS en tu p\u00e1gina"},{"location":"guide/css_and_js/#middleware","text":"Las etiquetas <link> y <script> de arriba no servir\u00e1n de nada si tu aplicaci\u00f3n no puede servir esos archivos, y no puede hacerlo a\u00fan. Por esa raz\u00f3n, Template Components incluye un middleware WSGI que procesar\u00e1 URLs como esas y devolver\u00e1 los archivos correctos, si lo agregas a tu aplicaci\u00f3n. from flask import Flask from tcom import Catalog app = Flask ( __name__ ) # Aqu\u00ed agregamos las variables globales, filtros, etc. de # las plantillas de Flask, como por ejemplo `url_for()` catalog = tcom . Catalog ( globals = app . jinja_env . globals , filters = app . jinja_env . filters , tests = app . jinja_env . tests , extensions = app . jinja_env . extensions , ) catalog . add_folder ( \"myapp/components\" ) app . wsgi_app = catalog . get_middleware ( app . wsgi_app , autorefresh = app . debug , ) El middleware usa la \u201cprobada en batalla\u201d librer\u00eda Whitenoise y solo devolver\u00e1 archivos .css y/o .js dentro de el(los) folder(s) de los componentes (puedes configurarlo para que tambi\u00e9n devuelva archivos con otras extensiones).","title":"Middleware"},{"location":"guide/css_and_js/#buenas-practicas","text":"","title":"Buenas pr\u00e1cticas"},{"location":"guide/css_and_js/#alcance-del-css","text":"Los estilos no se auto-limitar\u00e1n a tu componente. Esto significa que podr\u00edan afectar a otros componentes y, a la inversa, ser afectados por estilos globales o de otros componentes. Para protegerte de esto, siempre usa una clase \u00fanica en la(s) etiqueta(s) ra\u00edz del componente y \u00fasala para limitar el resto de los estilos. Ejemplo: components/Card.jinja {#css card.css #} {% do attrs.add_class ( \"Card\" ) - %} < div {{ attrs.render () }} > < h1 > My Card </ h1 > ... </ div > components/card.css /* \ud83d\udeab NO HAGAS ESTO */ h1 { font-size : 2 em ; } h2 { font-size : 1.5 em ; } a { color : blue ; } /* \ud83d\udc4d HAZ ESTO en vez */ . Card h1 { font-size : 2 em ; } . Card h2 { font-size : 1.5 em ; } . Card a { color : blue ; } Siempre usa una clase en vez de un id , o el componente no podr\u00e1 ser usado m\u00e1s de una vez en una misma p\u00e1gina.","title":"Alcance del CSS"},{"location":"guide/css_and_js/#eventos-de-javascript","text":"Tus componentes podr\u00edan ser insertados al vuelo en la p\u00e1gina, despu\u00e9s de que el JavaScript haya sido cargado y ejecutado. Por eso, conectar eventos a los elementos al cargar la p\u00e1gina no ser\u00e1 suficiente: components/card.js // Esto fallar\u00e1 para cualquier <Card> insertado despu\u00e9s document . querySelectorAll ( '.Card button.share' ) . forEach ( ( node ) => { node . addEventListener ( \"click\" , handleClick ) }) /* ... etc. ... */ Una alternativa puede ser usar el API JavaScript MutationObserver para detectar cambios en el documento y conectar eventos a los nuevos componentes insertados: components/card.js new MutationObserver ( ( mutationList ) => { mutationList . forEach ( ( mutation ) => { if ( mutation . type !== \"childList\" ) return mutation . addedNodes . forEach ( ( node ) => { if ( node . nodeType === 1 ) { addEvents ( node ) } }) }) }) . observe ( document . body , { subtree : true , childList : true , attributes : false , characterData : false }) function addEvents ( root ) { /* Agrega eventos a todos los elementos hijos de los nuevos elementos insertados */ root . querySelectorAll ( '.Card button.share' ) . forEach ( ( node ) => { node . addEventListener ( \"click\" , handleClick ) }) } // Una primera llamada para conectar los eventos a los componentes // presentes en la p\u00e1gina cuando carga addEvents ( document ) /* ... etc ... */","title":"Eventos de JavaScript"},{"location":"guide/extra/","text":"Argumentos extra # Si le pasas argumentos no declarados a un componentes, estos no son descartados si no, en cambio, recogidos en un objeto attrs que puede renderizar estos argumentos extra llamando a attrs.render() Por ejemplo, este componente: components/Card.jinja {#def title #} < div {{ attrs.render () }} > < h1 > {{ title }} </ h1 > {{ content }} </ div > usado como: < Card title = \"Products\" class = \"bg-blue-500 mb-10\" open > bla </ Card > ser\u00e1 renderizado a: < div class = \"bg-blue-500 mb-10\" open > < h1 > Products </ h1 > bla </ div > Puedes agregar o quitar argumentos, antes de renderizarlos, usando los otros m\u00e9todos del objeto attrs . Por ejemplo: {#def title #} {% do attrs.add_class ( \"card\" ) - %} < div {{ attrs.render () }} > < h1 > {{ title }} </ h1 > {{ content }} </ div > M\u00e9todos de attrs # .set(name=value, ...) # Agrega un atributo o activa una propiedad: - Usa un nombre y un valor para agregar un atributo (ej. type=\"text\" ) - Usa True como valor para activar una propiedad (ej. disabled ) - Usa False como valor para quitar un atributo o propiedad Los guiones bajos en los nombres ser\u00e1n reemplazados autom\u00e1ticamente por guiones, as\u00ed que aria_selected se volver\u00e1 el atributo aria-selected . Los atributos o propiedades son sobreescritos excepto si se trata de \u201cclass\u201d o \u201cclasses\u201d. En esos casos, las nuevas clases se agregan a las antiguas en vez de reemplazarlas. Agregando atributos/propiedades {% do attrs.set ( id = \"loremipsum\" , disabled = True , data_test = \"foobar\" , class = \"m-2 p-4\" , ) %} Quitando atributos/propiedades {% do attrs.set ( title = False , disabled = False , data_test = False , class = False , ) %} .setdefault(name=value, ...) # Agrega un atributo (ej. type=\"text\" ), pero solo si no est\u00e1 ya presente . {% do attrs.setdefault ( \"aria-label\" , \"Products\" ) %} .remove_class(name1, name2, ...) # Elimina una o m\u00e1s clases de la lista de clases. {% do attrs.remove_class ( \"hidden\" ) %} {% do attrs.remove_classes ( \"active\" , \"animated\" ) %} .get(name, default=None) # Devuelve el valor del atributo, o el valor de default si el atributo no existe. {% - set role = attrs.get ( \"role\" , \"tab\" ) .render() # Renderiza los atributos y propiedades como un texto. Para dar un resultado consistente, los atributos y propiedades se ordenan alfab\u00e9ticamente por nombre y renderizados as\u00ed: <attributor ordenados> + <propiedades ordenadas> . < button {{ attrs.render () }} > {{ content }} </ button > Cuidado Usar {{ attrs.render() }} para pasar los argumentos extra a otros componentes NO FUNCIONAR\u00c1 . Esto es porque los componentes se convierten a macros antes de renderizar la p\u00e1gina. Si necesitas que funcione, debes usar el argumento especial __attrs . {#--- MUY MAL \ud83d\ude35 ---#} < MyButton {{ attrs.render () }} /> {#--- BIEN \ud83d\udc4d ---#} < MyButton __attrs = { attrs } /> Otra opci\u00f3n es definir expl\u00edcitamente que argumentos necesitan los sub-componentes: {#def btn_class='' #} < MyButton class = {btn_class} />","title":"Argumentos extra"},{"location":"guide/extra/#argumentos-extra","text":"Si le pasas argumentos no declarados a un componentes, estos no son descartados si no, en cambio, recogidos en un objeto attrs que puede renderizar estos argumentos extra llamando a attrs.render() Por ejemplo, este componente: components/Card.jinja {#def title #} < div {{ attrs.render () }} > < h1 > {{ title }} </ h1 > {{ content }} </ div > usado como: < Card title = \"Products\" class = \"bg-blue-500 mb-10\" open > bla </ Card > ser\u00e1 renderizado a: < div class = \"bg-blue-500 mb-10\" open > < h1 > Products </ h1 > bla </ div > Puedes agregar o quitar argumentos, antes de renderizarlos, usando los otros m\u00e9todos del objeto attrs . Por ejemplo: {#def title #} {% do attrs.add_class ( \"card\" ) - %} < div {{ attrs.render () }} > < h1 > {{ title }} </ h1 > {{ content }} </ div >","title":"Argumentos extra"},{"location":"guide/extra/#metodos-de-attrs","text":"","title":"M\u00e9todos de attrs"},{"location":"guide/extra/#setnamevalue","text":"Agrega un atributo o activa una propiedad: - Usa un nombre y un valor para agregar un atributo (ej. type=\"text\" ) - Usa True como valor para activar una propiedad (ej. disabled ) - Usa False como valor para quitar un atributo o propiedad Los guiones bajos en los nombres ser\u00e1n reemplazados autom\u00e1ticamente por guiones, as\u00ed que aria_selected se volver\u00e1 el atributo aria-selected . Los atributos o propiedades son sobreescritos excepto si se trata de \u201cclass\u201d o \u201cclasses\u201d. En esos casos, las nuevas clases se agregan a las antiguas en vez de reemplazarlas. Agregando atributos/propiedades {% do attrs.set ( id = \"loremipsum\" , disabled = True , data_test = \"foobar\" , class = \"m-2 p-4\" , ) %} Quitando atributos/propiedades {% do attrs.set ( title = False , disabled = False , data_test = False , class = False , ) %}","title":".set(name=value, ...)"},{"location":"guide/extra/#setdefaultnamevalue","text":"Agrega un atributo (ej. type=\"text\" ), pero solo si no est\u00e1 ya presente . {% do attrs.setdefault ( \"aria-label\" , \"Products\" ) %}","title":".setdefault(name=value, ...)"},{"location":"guide/extra/#remove_classname1-name2","text":"Elimina una o m\u00e1s clases de la lista de clases. {% do attrs.remove_class ( \"hidden\" ) %} {% do attrs.remove_classes ( \"active\" , \"animated\" ) %}","title":".remove_class(name1, name2, ...)"},{"location":"guide/extra/#getname-defaultnone","text":"Devuelve el valor del atributo, o el valor de default si el atributo no existe. {% - set role = attrs.get ( \"role\" , \"tab\" )","title":".get(name, default=None)"},{"location":"guide/extra/#render","text":"Renderiza los atributos y propiedades como un texto. Para dar un resultado consistente, los atributos y propiedades se ordenan alfab\u00e9ticamente por nombre y renderizados as\u00ed: <attributor ordenados> + <propiedades ordenadas> . < button {{ attrs.render () }} > {{ content }} </ button > Cuidado Usar {{ attrs.render() }} para pasar los argumentos extra a otros componentes NO FUNCIONAR\u00c1 . Esto es porque los componentes se convierten a macros antes de renderizar la p\u00e1gina. Si necesitas que funcione, debes usar el argumento especial __attrs . {#--- MUY MAL \ud83d\ude35 ---#} < MyButton {{ attrs.render () }} /> {#--- BIEN \ud83d\udc4d ---#} < MyButton __attrs = { attrs } /> Otra opci\u00f3n es definir expl\u00edcitamente que argumentos necesitan los sub-componentes: {#def btn_class='' #} < MyButton class = {btn_class} />","title":".render()"}]}